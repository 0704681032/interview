笔试面试知识整理
=============

### 目录

* [网络](#网络)
    * [HTTP](#HTTP)
        * [HTTP的特性](#http的特性)
        * [HTTP报文](#http报文)
        * [持久连接](#持久连接)
        * [会话跟踪](#会话跟踪)
        * [跨站攻击](#跨站攻击)
    * [TCP](#tcp) 
        * [TCP的特性](#tcp的特性)
        * [三次握手与四次挥手](#三次握手与四次挥手)
        * [SYN攻击](#syn攻击)
    * [IP](#ip)
        * [广播与多播](#广播与多播)
        * [BGP](#bgp)
* [数据结构和算法](#数据结构和算法)
    * [树](#树)
        * [二叉树](#二叉树)
        * [堆](#堆)
        * [哈弗曼树](#哈弗曼树)
        * [二叉排序树](#二叉排序树)
        * [平衡二叉树](#平衡二叉树)
        * [B-树](#B-树)
* [体系结构和操作系统](#体系结构和操作系统)
    * [体系结构基础](#体系结构基础)
        * [冯·诺依曼体系结构](#冯·诺依曼体系结构)
        * [数据的机内表示](#数据的机内表示)
    * [操作系统基础](#操作系统基础)
        * [操作系统提供的服务](#操作系统提供的服务)
        * [中断与系统调用](#中断与系统调用)
    * [并发技术](#并发技术)
        * [进程](#进程)
        * [线程](#线程)
        * [协程](#协程)
        * [IO多路复用](#io多路复用)
    * [内存管理](#内存管理)
        * [内存分配](#内存分配)
        * [虚拟内存](#虚拟内存)
    * [磁盘与文件](#磁盘与文件)
        * [磁盘调度](#磁盘调度)
        * [文件系统](#文件系统)
* [数据库](#数据库)
    * [事务](#事务)
        * [事务的概念](#事务的概念)
        * [事务的特性](#事务的特性（acid）)
        * [事务的隔离级别](#事务的隔离级别)
        * [事务隔离的实现——锁](#事务隔离的实现锁)
* [编译原理](#编译原理)
    * [编译器](#编译器)
        * [编译器结构](#编译器结构)
        
        
网络
----

### HTTP

#### HTTP的特性

* HTTP构建于TCP/IP协议之上，默认端口号是80
* HTTP是**无连接无状态**的

#### HTTP报文

HTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是`GET`，`POST`，`PUT`，`DELETE`。`URL`全称是资源描述符，我们可以这样认为：一个`URL`地址，它用于描述一个网络上的资源，而 HTTP 中的`GET`，`POST`，`PUT`，`DELETE`就对应着对这个资源的查，改，增，删4个操作。

1. GET用于信息获取，而且应该是安全的和幂等的。

    所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。
    
    幂等的意味着对同一URL的多个请求应该返回同样的结果。
    
    GET请求报文示例：
    
        GET /books/?sex=man&name=Professional HTTP/1.1
        Host: www.wrox.com
        User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
        Gecko/20050225 Firefox/1.0.1
        Connection: Keep-Alive
        
2. POST表示可能修改变服务器上的资源的请求。
        
        POST / HTTP/1.1
        Host: www.wrox.com
        User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
        Gecko/20050225 Firefox/1.0.1
        Content-Type: application/x-www-form-urlencoded
        Content-Length: 40
        Connection: Keep-Alive
        
        sex=man&name=Professional  
              
3. 注意:

    * GET可提交的数据量受到URL长度的限制，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制
    * 理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制
    * 参考上面的报文示例，可以发现GET和POST数据内容是一模一样的，只是位置不同，一个在URL里，一个在HTTP包的包体里

#### 持久连接

我们知道 HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。

在 HTTP 1.0 版本中，并没有官方的标准来规定 Keep-Alive 如何工作，因此实际上它是被附加到 HTTP 1.0协议上，如果客户端浏览器支持 Keep-Alive ，那么就在HTTP请求头中添加一个字段 Connection: Keep-Alive，当服务器收到附带有 Connection: Keep-Alive 的请求时，它也会在响应头中添加一个同样的字段来使用 Keep-Alive 。这样一来，客户端和服务器之间的HTTP连接就会被保持，不会断开（超过 Keep-Alive 规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接

在 HTTP 1.1 版本中，默认情况下所有连接都被保持，如果加入 "Connection: close" 才关闭。目前大部分浏览器都使用 HTTP 1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep-Alive 连接就看服务器设置情况。

由于 HTTP 1.0 没有官方的 Keep-Alive 规范，并且也已经基本被淘汰，以下讨论均是针对 HTTP 1.1 标准中的 Keep-Alive 展开的。

注意：

* HTTP Keep-Alive 简单说就是保持当前的TCP连接，避免了重新建立连接

* HTTP 长连接不可能一直保持，例如 `Keep-Alive: timeout=5, max=100`，表示这个TCP通道可以保持20秒，max=100，表示这个长连接最多接收100次请求就断开。

* HTTP是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive没能改变这个结果。另外，Keep-Alive也不能保证客户端和服务器之间的连接一定是活跃的，在HTTP1.1版本中也如此。唯一能保证的就是当连接被关闭时你能得到一个通知，所以不应该让程序依赖于Keep-Alive的保持连接特性，否则会有意想不到的后果。

* 使用长连接之后，客户端、服务端怎么知道本次传输结束呢？两部分：1是判断传输数据是否达到了Content-Length 指示的大小；2动态生成的文件没有 Content-Length ，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后有一个空 chunked块，表明本次传输数据结束，详见[这里](http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html)。


#### 会话跟踪

1. 什么是会话？

    客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。
    
2. 什么是会话跟踪？

    会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。
    
3. 为什么需要会话跟踪？

    浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是”无状态”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才有会话跟踪技术来实现这种要求。
    
    
4. 会话跟踪常用的方法:

    1. URL重写
       
       URL(统一资源定位符)是Web上特定页面的地址，URL重写的技术就是在URL结尾添加一个附加数据以标识该会话,把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。


    2. 隐藏表单域
    
       将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示


    3. Cookie
    
        Cookie是Web服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将Cookie发送到客户端,在客户端可以进行保存,以便下次使用。
        
        客户端可以采用两种方式来保存这个Cookie对象，一种方式是保存在客户端内存中，称为临时Cookie，浏览器关闭后这个Cookie对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久Cookie。以后客户端只要访问该网站，就会将这个Cookie再次发送到服务器上，前提是这个Cookie在有效期内，这样就实现了对客户的跟踪。
        
        Cookie是可以被禁止的。

    4. Session:

        每一个用户都有一个不同的session，各个用户之间是不能共享的，是每个用户所独享的，在session中可以存放信息。
        
        在服务器端会创建一个session对象，产生一个sessionID来标识这个session对象，然后将这个sessionID放入到Cookie中发送到客户端，下一次访问时，sessionID会发送到服务器，在服务器端进行识别不同的用户。
        
        Session的实现依赖于Cookie，如果Cookie被禁用，那么session也将失效。

#### 跨站攻击

* CSRF（Cross-site request forgery，跨站请求伪造）

    CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。
    
    例如，一论坛网站的发贴是通过 GET 请求访问，点击发贴之后 JS 把发贴内容拼接成目标 URL 并访问：
    
        http://example.com/bbs/create_post.php?title=标题&content=内容

    那么，我们只需要在论坛中发一帖，包含一链接：

        http://example.com/bbs/create_post.php?title=我是脑残&content=哈哈
        
    只要有用户点击了这个链接，那么他们的帐户就会在不知情的情况下发布了这一帖子。可能这只是个恶作剧，但是既然发贴的请求可以伪造，那么删帖、转帐、改密码、发邮件全都可以伪造。
    
    **如何防范 CSRF 攻击**？可以注意以下几点：
    
    * 关键操作只接受POST请求

    * 验证码
        
      CSRF攻击的过程，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了CSRF攻击。

      但是如果你在一个网站作出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时候使用。

    * 检测refer

      常见的互联网页面与页面之间是存在联系的，比如你在www.baidu.com应该是找不到通往www.google.com的链接的，再比如你在论坛留言，那么不管你留言后重定向到哪里去了，之前的那个网址一定会包含留言的输入框，这个之前的网址就会保留在新页面头文件的Referer中

    通过检查Referer的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都能接受到Referer的值，所以Refere Check 一般用于监控CSRF攻击的发生，而不用来抵御攻击。

    * Token

      目前主流的做法是使用Token抵御CSRF攻击。下面通过分析CSRF 攻击来理解为什么Token能够有效

      CSRF攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止CSRF攻击。

      另一个更通用的做法是保持原有参数不变，另外添加一个参数Token，其值是随机的。这样攻击者因为不知道Token而无法构造出合法的请求进行攻击。

    Token 使用原则

    * Token要足够随机————只有这样才算不可预测
    * Token是一次性的，即每次请求成功后要更新Token————这样可以增加攻击难度，增加预测难度
    * Token要注意保密性————敏感操作使用post，防止Token出现在URL中

    **注意**：过滤用户输入的内容**不能**阻挡 csrf，我们需要做的是过滤请求的**来源**。

* XSS（Cross Site Scripting，跨站脚本攻击）

    XSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。
    
    运行预期之外的脚本带来的后果有很多中，可能只是简单的恶作剧——一个关不掉的窗口：

        while (true) {
            alert("你关不掉我~");
        }

    也可以是盗号或者其他未授权的操作。
    
    XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。
    
    **如何防御 XSS 攻击？**
    
    理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在XSS漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于script。防御 XSS 攻击最简单直接的方法，就是过滤用户的输入。
    
    如果不需要用户输入 HTML，可以直接对用户的输入进行 HTML escape 。下面一小段脚本：
    
        <script>window.location.href=”http://www.baidu.com”;</script>
        
    经过 escape 之后就成了：
    
        &lt;script&gt;window.location.href=&quot;http://www.baidu.com&quot;&lt;/script&gt;
       
    它现在会像普通文本一样显示出来，变得无毒无害，不能执行了。
    
    当我们需要用户输入 HTML 的时候，需要对用户输入的内容做更加小心细致的处理。仅仅粗暴地去掉 script 标签是没有用的，任何一个合法 HTML 标签都可以添加 onclick 一类的事件属性来执行 JavaScript。更好的方法可能是，将用户的输入使用 HTML 解析库进行解析，获取其中的数据。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从**白名单**中拿取。

参考资料：

* [浅谈HTTP中Get与Post的区别](http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html)
* [HTTP中的长连接与短连接](http://www.cnblogs.com/cswuyg/p/3653263.html)
* [HTTP Keep-Alive模式](http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html)
* [HTTP协议及其POST与GET操作差异 & C#中如何使用POST、GET等](http://www.cnblogs.com/skynet/archive/2010/05/18/1738301.html)
* [会话跟踪](http://blog.163.com/chfyljt@126/blog/static/11758032520127302714624/)
* [总结 XSS 与 CSRF 两种跨站攻击](https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/)
* [CSRF简单介绍与利用方法](http://drops.wooyun.org/papers/155)
* [XSS攻击及防御](http://blog.csdn.net/ghsau/article/details/17027893)
* [百度百科：HTTP](http://baike.baidu.com/view/9472.htm)

### TCP

#### TCP的特性

* TCP提供一种**面向连接的、可靠的**字节流服务
* 在一个TCP连接中，仅有两方进行彼此通信。广播和多播不能用于TCP
* TCP使用校验和，确认和重传机制来保证可靠传输
* TCP使用累积确认
* TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制


#### 三次握手与四次挥手

* 所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。

    三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 `connect()` 时。将触发三次握手。
    
    
    * 第一次握手(SYN=1, seq=x):
    
        客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。

        发送完毕后，客户端进入 `SYN_SEND` 状态。
        
    * 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):
    
        服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 
        发送完毕后，服务器端进入 `SYN_RCVD` 状态。

    * 第三次握手(ACK=1，ACKnum=y+1)
        
        客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1
        
        发送完毕后，客户端进入 `ESTABLISHED` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED` 状态，TCP 握手结束。

* TCP的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 `close()` 操作即可产生挥手操作。

    * 第一次挥手(FIN=1，seq=x)
        
        假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。
        
        发送完毕后，客户端进入 `FIN_WAIT_1` 状态。
        
    * 第二次挥手(ACK=1，ACKnum=x+1)
    
        服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。
        
        发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，等待服务器端关闭连接。
        
    * 第三次挥手(FIN=1，seq=y)

        服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。
        
        发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个ACK。
        
    * 第四次挥手(ACK=1，ACKnum=y+1)
    
        客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 `TIME_WAIT `状态，等待可能出现的要求重传的 ACK 包。
        
        服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。
        
        客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。
        

#### SYN攻击

* 什么是 SYN 攻击（SYN Flood）？

    在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYC_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.

    SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。
    
    SYN 攻击是一种典型的 DoS/DDoS 攻击。
    
* 如何检测 SYN 攻击？

     检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 攻击来检测 SYN 攻击。
     
* 如何防御 SYN 攻击？

    SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：
    
    * 缩短超时（SYN Timeout）时间
    * 增加最大半连接数
    * 过滤网关防护
    * SYN cookies技术
     

参考资料: 

* 计算机网络：自顶向下方法
* [TCP三次握手及四次挥手详细图解](http://www.cnblogs.com/hnrainll/archive/2011/10/14/2212415.html)
* [TCP协议三次握手过程分析](http://www.cnblogs.com/rootq/articles/1377355.html)
* [TCP协议中的三次握手和四次挥手(图解)](http://blog.csdn.net/whuslei/article/details/6667471)
* [百度百科：SYN攻击](http://baike.baidu.com/subview/32754/8048820.htm)

### IP

#### 广播与多播

广播和多播仅用于UDP（TCP是面向连接的）。

* 广播

    一共有四种广播地址：
  
    1. 受限的广播
   
     受限的广播地址为255.255.255.255。该地址用于主机配置过程中IP数据报的目的地址，在任何情况下，router不转发目的地址为255.255.255.255的数据报，这样的数据报仅出现在本地网络中。
     
    2. 指向网络的广播
   
     指向网络的广播地址是主机号为全1的地址。A类网络广播地址为netid.255.255.255，其中netid为A类网络的网络号。
    
     一个router必须转发指向网络的广播，但它也必须有一个不进行转发的选择。
    
    3. 指向子网的广播
  
     指向子网的广播地址为主机号为全1且有特定子网号的地址。作为子网直接广播地址的IP地址需要了解子网的掩码。例如，router收到128.1.2.255的数据报，当B类网路128.1的子网掩码为255.255.255.0时，该地址就是指向子网的广播地址；但是如果子网掩码为255.255.254.0，该地址就不是指向子网的广播地址。
    
    4. 指向所有子网的广播
    
     指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开来。指向所有子网的广播地址的子网号和主机号为全1.例如，如果子网掩码为255.255.255.0，那么128.1.255.255就是一个指向所有子网的广播地址。
    
     当前的看法是这种广播是陈旧过时的，更好的方式是使用多播而不是对所有子网的广播。
  
    广播示例:
  
        PING 192.168.0.255 (192.168.0.255): 56 data bytes
        64 bytes from 192.168.0.107: icmp_seq=0 ttl=64 time=0.199 ms
        64 bytes from 192.168.0.106: icmp_seq=0 ttl=64 time=45.357 ms 
        64 bytes from 192.168.0.107: icmp_seq=1 ttl=64 time=0.203 ms
        64 bytes from 192.168.0.106: icmp_seq=1 ttl=64 time=269.475 ms  
        64 bytes from 192.168.0.107: icmp_seq=2 ttl=64 time=0.102 ms
        64 bytes from 192.168.0.106: icmp_seq=2 ttl=64 time=189.881 ms
       
  可以看到的确收到了来自两个主机的答复，其中 192.168.0.107 是本机地址。

* 多播

    多播又叫组播，使用D类地址，D类地址分配的28bit均用作多播组号而不再表示其他。
    
    多播组地址包括1110的最高4bit和多播组号。它们通常可以表示为点分十进制数，范围从224.0.0.0到239.255.255.255。
    
    多播的出现减少了对应用不感兴趣主机的处理负荷。
    
    多播的特点：
    
    * 允许一个或多个发送者（组播源）发送单一的数据包到多个接收者（一次的，同时的）的网络技术
    * 可以大大的节省网络带宽，因为无论有多少个目标地址，在整个网络的任何一条链路上只传送单一的数据包 
    * 多播技术的核心就是针对如何节约网络资源的前提下保证服务质量。 
    
    
    多播示例：
    
        PING 224.0.0.1 (224.0.0.1): 56 data bytes
        64 bytes from 192.168.0.107: icmp_seq=0 ttl=64 time=0.081 ms
        64 bytes from 192.168.0.106: icmp_seq=0 ttl=64 time=123.081 ms
        64 bytes from 192.168.0.107: icmp_seq=1 ttl=64 time=0.122 ms
        64 bytes from 192.168.0.106: icmp_seq=1 ttl=64 time=67.312 ms
        64 bytes from 192.168.0.107: icmp_seq=2 ttl=64 time=0.132 ms
        64 bytes from 192.168.0.106: icmp_seq=2 ttl=64 time=447.073 ms
        64 bytes from 192.168.0.107: icmp_seq=3 ttl=64 time=0.132 ms
        64 bytes from 192.168.0.106: icmp_seq=3 ttl=64 time=188.800 ms
        
        
#### BGP

* 边界网关协议（BGP）是运行于 TCP 上的一种自治系统的路由协议

* BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关路由域间的多路连接的协议

* BGP是一种外部网关协议（Exterior Gateway Protocol，EGP），与OSPF、RIP等内部网关协议（Interior Gateway Protocol，IGP）不同，BGP不在于发现和计算路由，而在于控制路由的传播和选择最佳路由

* BGP使用TCP作为其传输层协议（端口号179），提高了协议的可靠性

* BGP既不是纯粹的矢量距离协议，也不是纯粹的链路状态协议 

* BGP支持CIDR（Classless Inter-Domain Routing，无类别域间路由）
    
* 路由更新时，BGP只发送更新的路由，大大减少了BGP传播路由所占用的带宽，适用于在Internet上传播大量的路由信息
   
* BGP路由通过携带AS路径信息彻底解决路由环路问题
    
* BGP提供了丰富的路由策略，能够对路由实现灵活的过滤和选择
    
* BGP易于扩展，能够适应网络新的发展


参考资料:

* [多播与广播](http://www.cnblogs.com/Torres_fans/archive/2011/03/21/1990377.html)
* [TCP_IP：广播和多播](http://blog.sina.com.cn/s/blog_ac9fdc0b0101pw7w.html)
* [百度百科：BGP](http://baike.baidu.com/view/875886.htm?fromtitle=bgp&fromid=91408&type=syn)


数据结构和算法
------------

### 树

#### 二叉树

**二叉树**：二叉树是有限个结点的集合，这个集合或者是空集，或者是由一个根结点和两株互不相交的二叉树组成，其中一株叫根的做左子树，另一棵叫做根的右子树。

**二叉树的性质**：

* 性质1：在二叉树中第 i 层的结点数最多为2^(i-1)（i ≥ 1）
* 性质2：高度为k的二叉树其结点总数最多为2^k－1（ k ≥ 1）
* 性质3：对任意的非空二叉树 T ，如果叶结点的个数为 n0，而其度为 2 的结点数为 n2，则：`n0 = n2 + 1`

**满二叉树**：深度为k且有2^k －1个结点的二叉树称为满二叉树

**完全二叉树**：深度为 k 的，有n个结点的二叉树，当且仅当其每个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应，称之为完全二叉树。（除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点）

* 性质4：具有 n 个结点的完全二叉树的深度为 log2n + 1

**注意**：

* 仅有前序和后序遍历，不能确定一个二叉树，必须有中序遍历的结果

#### 堆

如果一棵完全二叉树的任意一个非终端结点的元素都不小于其左儿子结点和右儿子结点（如果有的话）
的元素，则称此完全二叉树为最大堆。
        
同样，如果一棵完全二叉树的任意一个非终端结点的元素都不大于其左儿子结点和右儿子结点（如果
有的话）的元素，则称此完全二叉树为最小堆。

**最大堆的根结点中的元素在整个堆中是最大的；**

**最小堆的根结点中的元素在整个堆中是最小的。**

#### 哈弗曼树

* 定义：给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。

* 构造：

    假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：
    
    1. 将w1、w2、…，wn看成是有 n 棵树的森林(每棵树仅有一个结点)；
    2. 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；
    3. 从森林中删除选取的两棵树，并将新树加入森林；
    4. 重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。

    
#### 二叉排序树

二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。

二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

1. 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
2. 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
3. 左、右子树也分别为二叉排序树；
4. 没有键值相等的节点

二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)（相当于顺序查找）

#### 平衡二叉树

平衡二叉树（balanced  binary  tree）,又称 AVL 树。它或者是一棵空树,或者是具有如下性质的二叉树：

1. 它的左子树和右子树都是平衡二叉树，
2. 左子树和右子树的深度之差的绝对值不超过1。

平衡二叉树是对二叉搜索树(又称为二叉排序树)的一种改进。二叉搜索树有一个缺点就是，树的结构是无法预料的，随意性很大，它只与节点的值和插入的顺序有关系，往往得到的是一个不平衡的二叉树。在最坏的情况下，可能得到的是一个单支二叉树，其高度和节点数相同，相当于一个单链表，对其正常的时间复杂度有O(log(n))变成了O(n)，从而丧失了二叉排序树的一些应该有的优点。


#### B-树

**B-树**：B-树是一种非二叉的查找树， 除了要满足查找树的特性，还要满足以下结构特性：

一棵 m 阶的B-树：

1. 树的根或者是一片叶子(一个节点的树),或者其儿子数在 2 和 m 之间。
2. 除根外，所有的非叶子结点的孩子数在 m/2 和 m 之间。
3. 所有的叶子结点都在相同的深度。   

B-树的平均深度为logm/2(N)。执行查找的平均时间为O(logm)；


参考资料：

* [百度百科：哈弗曼树](http://baike.baidu.com/view/127820.htm)
* [百度百科：二叉排序树](http://baike.baidu.com/view/647462.htm)
* [百度百科：平衡二叉树](http://baike.baidu.com/view/593144.htm)
* [平衡二叉树及其应用场景](http://blog.csdn.net/huiguixian/article/details/6360682)
* [百度百科：B-树](http://baike.baidu.com/view/2228473.htm)


体系结构和操作系统
---------------

### 体系结构基础

#### 冯·诺依曼体系结构

1. 计算机处理的数据和指令一律用二进制数表示
2. 顺序执行程序

   计算机运行过程中，把要执行的程序和处理的数据首先存入主存储器（内存），计算机执行程序时，将自动地并按顺序从主存储器中取出指令一条一条地执行，这一概念称作顺序执行程序。

3. 计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成。

#### 数据的机内表示

##### 二进制表示

1. 机器数
   
   由于计算机中符号和数字一样,都必须用二进制数串来表示,因此,正负号也必须用0、1来表示。
   
   用最高位0表示正、1表示负, 这种正负号数字化的机内表示形式就称为“机器数”,而相应的机器外部用正负号表示的数称为“真值”,将一个真值表示成二进制字串的机器数的过程就称为编码。

2. 原码

   原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

   [+1]原 = 0000 0001

   [-1]原 = 1000 0001

   第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:

   [1111 1111 , 0111 1111]

   即

   [-127 , 127]

   原码是人脑最容易理解和计算的表示方式

3. 反码

   反码的表示方法是:

   正数的反码是其本身

   负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

   [+1] = [00000001]原 = [00000001]反

   [-1] = [10000001]原 = [11111110]反

   可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算

4. 补码

   补码的表示方法是:

   正数的补码就是其本身

   负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1。 (即在反码的基础上+1)

   [+1] = [00000001]原 = [00000001]反 = [00000001]补

   [-1] = [10000001]原 = [11111110]反 = [11111111]补

   对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值. 

5. 定点数与浮点数

   定点数是小数点固定的数。在计算机中没有专门表示小数点的位，小数点的位置是约定默认的。一般固定在机器数的最低位之后，或是固定在符号位之后。前者称为定点纯整数，后者称为定点纯小数。
   
   定点数表示法简单直观，但是数值表示的范围太小，运算时容易产生溢出。 
   
   
   浮点数是小数点的位置可以变动的数。为增大数值表示范围，防止溢出，采用浮点数表示法。浮点表示法类似于十进制中的科学计数法。
    
   在计算机中通常把浮点数分成阶码和尾数两部分来表示，其中阶码一般用补码定点整数表示，尾数一般用补码或原码定点小数表示。为保证不损失有效数字，对尾数进行规格化处理，也就是平时所说的科学记数法，即保证尾数的最高位为1，实际数值通过阶码进行调整
   
   
   阶符表示指数的符号位、阶码表示幂次、数符表示尾数的符号位、尾数表示规格化后的小数值。
             
   `N = 尾数×基数阶码（指数）`
   
   
##### 位(Bit)、字节(Byte)、字(Word)

位："位(bit)"是电子计算机中最小的数据单位。每一位的状态只能是0或1。

字节：8个二进制位构成1个"字节(Byte)"，它是存储空间的基本计量单位。1个字节可以储存1个英文字母或者半个汉字，换句话说，1个汉字占据2个字节的存储空间。

字："字"由若干个字节构成，字的位数叫做字长，不同档次的机器有不同的字长。例如一台8位机，它的1个字就等于1个字节，字长为8位。如果是一台16位机，那么，它的1个字就由2个字节构成，字长为16位。字是计算机进行数据处理和运算的单位。

##### 字节序

字节顺序是指占内存多于一个字节类型的数据在内存中的存放顺序，通常有小端、大端两种字节顺序。

小端字节序指低字节数据存放在内存低地址处，高字节数据存放在内存高地址处；

大端字节序是高字节数据存放在低地址处，低字节数据存放在高地址处。

基于X86平台的PC机是小端字节序的，而有的嵌入式平台则是大端字节序的。所有网络协议也都是采用big endian的方式来传输数据的。所以有时我们也会把big endian方式称之为网络字节序。

比如数字0x12345678在两种不同字节序CPU中的存储顺序如下所示：

    Big Endian
    低地址                                            高地址
    ---------------------------------------------------->
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     12     |      34    |     56      |     78    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    Little Endian
    低地址                                            高地址
    ---------------------------------------------------->
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     78     |      56    |     34      |     12    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     
     
从上面两图可以看出，采用Big Endian方式存储数据是符合我们人类的思维习惯的。
 
 
联合体`union`的存放顺序是所有成员都从低地址开始存放，利用该特性，就能判断CPU对内存采用Little-endian还是Big-endian模式读写。
 
示例代码如下：

```c
union test{  
    short  i;  
    char str[sizeof(short)];  
}tt;  
  
void main()  
{  
    tt.i = 0x0102;  
    if(sizeof(short) == 2)  
        {  
            if(tt.str[0] == 1 && tt.str[1] == 2)  
                printf("大端字节序");  
            else if(tt.str[0] = 2 && tt.str[1] == 1)  
                printf("小端字节序");  
            else  
                printf("结果未知");  
         }  
    else  
        printf("sizof(short)=%d,不等于2",sizeof(short));  
}  
```

##### 字节对齐

现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。

* 为什么要进行字节对齐？

  1. 某些平台只能在特定的地址处访问特定类型的数据; 
  2. 最根本的原因是效率问题，字节对齐能提⾼存取数据的速度。

比如有的平台每次都是从偶地址处读取数据,对于一个int型的变量,若从偶地址单元处存放,则只需一个读取周期即可读取该变量，但是若从奇地址单元处存放,则需要2个读取周期读取该变量。

* 字节对齐的原则

  1. 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在 offset 为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在32位机为4字节,则要从4的整数倍地址开始存储。
   
  2. 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储。)

  3. 收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍，不足的要补齐。

参考资料：
 
* [百度百科：冯·诺依曼体系结构](http://baike.baidu.com/view/9427882.htm)
* [二进制原码、反码、补码](http://blog.csdn.net/yinyhy/article/details/8732118)
* [什么是位、字节、字、KB、MB?](http://jingyan.baidu.com/article/ad310e808e90b71849f49eae.html)
* [定点数与浮点数](http://jsjedu.hxu.edu.cn/dxjsjjc/kcnr/wlkj/03architecture/detail/3-1-5.htm)
* [大小字节序](http://blog.csdn.net/mfc5158/article/details/6991374)
* [浅谈字节序(Byte Order)及其相关操作](http://www.cnblogs.com/JeffreyZhao/archive/2010/02/10/byte-order-and-related-library.html)
* [大小端字节序的判断](http://blog.csdn.net/lyh66/article/details/7478474)
* [百度百科：字节对齐](http://baike.baidu.com/view/1523557.htm)
* [五分钟搞定内存对齐](http://blog.csdn.net/hairetz/article/details/4084088)

### 操作系统基础

#### 操作系统提供的服务

操作系统的五大功能，分别为：作业管理、文件管理、存储管理、输入输出设备管理、进程及处理机管理

#### 中断与系统调用

#####  中断

所谓的中断就是在计算机执行程序的过程中，由于出现了某些特殊事情，使得CPU暂停对程序的执行，转而去执行处理这一事件的程序。等这些特殊事情处理完之后再回去执行之前的程序。中断一般分为三类：

1. 由计算机硬件异常或故障引起的中断，称为内部异常中断；
2. 由程序中执行了引起中断的指令而造成的中断，称为软中断（这也是和我们将要说明的系统调用相关的中断）；
3. 由外部设备请求引起的中断，称为外部中断。简单来说，对中断的理解就是对一些特殊事情的处理。

与中断紧密相连的一个概念就是中断处理程序了。当中断发生的时候，系统需要去对中断进行处理，对这些中断的处理是由操作系统内核中的特定函数进行的，这些处理中断的特定的函数就是我们所说的中断处理程序了。

另一个与中断紧密相连的概念就是中断的优先级。中断的优先级说明的是当一个中断正在被处理的时候，处理器能接受的中断的级别。中断的优先级也表明了中断需要被处理的紧急程度。每个中断都有一个对应的优先级，当处理器在处理某一中断的时候，只有比这个中断优先级高的中断可以被处理器接受并且被处理。优先级比这个当前正在被处理的中断优先级要低的中断将会被忽略。

典型的中断优先级如下所示：

    机器错误 > 时钟 > 磁盘 > 网络设备 >  终端 > 软件中断

当发生软件中断时，其他所有的中断都可能发生并被处理；但当发生磁盘中断时，就只有时钟中断和机器错误中断能被处理了。

##### 系统调用

在讲系统调用之前，先说下进程的执行在系统上的两个级别：用户级和核心级，也称为用户态和系统态(user mode and kernel mode)。

程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件等，就需要向操作系统发出调用服务的请求，这就是系统调用。

Linux系统有专门的函数库来提供这些请求操作系统服务的入口，这个函数库中包含了操作系统说提供的对外服务的接口。当进程发出系统调用之后，它所处的运行状态就会由用户态变成核心态。但这个时候，进程本身其实并没有做什么事情，这个时候是由内核在做相应的操作，去完成进程所提出的这些请求。

系统调用和中断的关系就在于，当进程发出系统调用申请的时候，会产生一个软件中断。产生这个软件中断以后，系统会去对这个软中断进行处理，这个时候进程就处于核心态了。

那么用户态和核心态之间的区别是什么呢？（以下区别摘至《UNIX操作系统设计》）

1. 用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据）。然而，核心态下的进程能够存取内核和用户地址
2. 某些机器指令是特权指令，在用户态下执行特权指令会引起错误

对此要理解的一个是，在系统中内核并不是作为一个与用户进程平行的估计的进程的集合，内核是为用户进程运行的。


参考资料：

* [Linux系统的中断、系统调用于调度概述](http://www.linuxidc.com/Linux/2012-11/74486.htm)

### 并发技术
 
**什么是并发？**

在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。

这里需要注意并发和并行是不同的两个概念。并发是指一个时间段内同时运行，这是个区间；而并行是指在同一个时间点上运行，这个是一个点。而且并发在同一个时间点上只能是一个程序在运行。


#### 进程

进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。

进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。

##### 进程的基本状态

1. 等待态：等待某个事件的完成；
2. 就绪态：等待系统分配处理器以便运行；
3. 运行态：占有处理器正在运行。

运行态→等待态 往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。

等待态→就绪态 则是等待的条件已满足，只需分配到处理器后就能运行。

运行态→就绪态 不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。

就绪态→运行态 系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态


##### 进程调度

###### 调度种类

高级、中级和低级调度作业从提交开始直到完成，往往要经历下述三级调度：

* 高级调度：(High-Level Scheduling)又称为作业调度，它决定把后备作业调入内存运行；
* 低级调度：(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU；
* 中级调度：(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。

###### 非抢占式调度与抢占式调度

* 非抢占式

  分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另一个进程。
  
* 抢占式

  操作系统将正在运行的进程强行暂停，由调度程序将CPU分配给其他就绪进程的调度方式。
  
###### 调度策略的设计

响应时间: 从用户输入到产生反应的时间

周转时间: 从任务开始到任务结束的时间

CPU任务可以分为交互式任务和批处理任务，调度最终的目标是合理的使用CPU，使得交互式任务的响应时间尽可能短，用户不至于感到延迟，同时使得批处理任务的周转时间尽可能短，减少用户等待的时间。

###### 调度算法

1. FIFO或First Come, First Served (FCFS)
  
  调度的顺序就是任务到达就绪队列的顺序。
  
  公平、简单(FIFO队列)、非抢占、不适合交互式。未考虑任务特性，平均等待时间可以缩短
  
2. Shortest Job First (SJF)

  最短的作业(CPU区间长度最小)最先调度。
  
  可以证明，SJF可以保证最小的平均等待时间。
  
  * Shortest Remaining Job First (SRJF)

    SJF的可抢占版本，比SJF更有优势。
  
  SJF(SRJF): 如何知道下一CPU区间大小？根据历史进行预测: 指数平均法。
  
  
3. 优先权调度

  每个任务关联一个优先权，调度优先权最高的任务。
  
  注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。
  
  FCFS是RR的特例，SJF是优先权调度的特例。这些调度算法都不适合于交互式系统。
  
4. Round-Robin(RR) 

  设置一个时间片，按时间片来轮转调度（“轮叫”算法）
  
  优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多；
  
  如何确定时间片？
  
  时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS。
  
5. 多级队列调度

  * 按照一定的规则建立多个进程队列
  * 不同的队列有固定的优先级（高优先级有抢占权）
  * 不同的队列可以给不同的时间片和采用不同的调度方法

  存在问题1：没法区分I/O bound和CPU bound；

  存在问题2：也存在一定程度的“饥饿”现象；

6. 多级反馈队列

  在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务。

  可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”。

  最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows等。

##### 进程同步

###### 临界资源与临界区

在操作系统中，进程是占有资源的最小单位（线程可以访问其所在进程内的所有资源，但线程本身并不占有资源或仅仅占有一点必须资源）。但对于某些资源来说，其在同一时间只能被一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源。典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等(如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题)。

对于临界资源的访问，必须是互斥进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。而进程内访问临界资源的代码被成为临界区。

对于临界区的访问过程分为四个部分：

1. 进入区:查看临界区是否可访问，如果可以访问，则转到步骤二，否则进程会被阻塞

2. 临界区:在临界区做操作

3. 退出区:清除临界区被占用的标志

4. 剩余区：进程与临界区不相关部分的代码

解决临界区问题可能的方法：

1. 一般软件方法

2. 关中断方法

3. 硬件原子指令方法

4. 信号量方法

###### 信号量

信号量是一个确定的二元组（s，q），其中s是一个具有非负初值的整形变量，q是一个初始状态为空的队列，整形变量s表示系统中某类资源的数目：

* 当其值 ≥ 0 时，表示系统中当前可用资源的数目
* 当其值 ＜ 0 时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目

除信号量的初值外，信号量的值仅能由P操作和V操作更改，操作系统利用它的状态对进程和资源进行管理

P操作：
 
P操作记为P(s)，其中s为一信号量，它执行时主要完成以下动作：


    s.value = s.value - 1；  /*可理解为占用1个资源，若原来就没有则记帐“欠”1个*/
 
若s.value ≥ 0，则进程继续执行，否则（即s.value < 0），则进程被阻塞，并将该进程插入到信号量s的等待队列s.queue中
 
说明：实际上，P操作可以理解为分配资源的计数器，或是使进程处于等待状态的控制指令

V操作：
 
V操作记为V(s)，其中s为一信号量，它执行时，主要完成以下动作：

    s.value = s.value + 1；/*可理解为归还1个资源，若原来就没有则意义是用此资源还1个欠帐*/
 
若s.value > 0，则进程继续执行，否则（即s.value ≤ 0）,则从信号量s的等待队s.queue中移出第一个进程，使其变为就绪状态，然后返回原进程继续执行
 
说明：实际上，V操作可以理解为归还资源的计数器，或是唤醒进程使其处于就绪状态的控制指令      


信号量方法实现：生产者 − 消费者互斥与同步控制

    semaphore fullBuffers = 0; /*仓库中已填满的货架个数*/
    semaphore emptyBuffers = BUFFER_SIZE;/*仓库货架空闲个数*/
    semaphore mutex = 1; /*生产-消费互斥信号*/
    
    Producer() 
    { 
        while(True)
        {  
           /*生产产品item*/
           emptyBuffers.P(); 
           mutex.P(); 
           /*item存入仓库buffer*/
           mutex.V();
           fullBuffers.V();
        }
    }
     
    Consumer() 
    {
        while(True)
        {
            fullBuffers.P(); 
            mutex.P();	
            /*从仓库buffer中取产品item*/
            mutex.V();
            emptyBuffers.V();
            /*消费产品item*/
        }
    }


###### 死锁

死锁: 多个进程因循环等待资源而造成无法执行的现象。

死锁会造成进程无法执行，同时会造成系统资源的极大浪费(资源无法释放)。

死锁产生的4个必要条件：

* 互斥使用(Mutual exclusion)

  指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。

* 不可抢占(No preemption)

  指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
  
* 请求和保持(Hold and wait)
  
  指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
  
* 循环等待(Circular wait)
  指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
  
死锁避免——银行家算法

思想: 判断此次请求是否造成死锁若会造成死锁，则拒绝该请求

##### 进程间通信

进程间通信可以有7种方式：
 
pipe，named pipe，semophore,message queue,signal,shared memory,socket 


#### 线程 

线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。

线程具有以下属性：

1. 轻型实体
  线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。TCB包括以下信息：

  1. 线程状态。
  2. 当线程不运行时，被保存的现场资源。
  3. 一组执行堆栈。
  4. 存放每个线程的局部变量主存区。
  5. 访问同一个进程中的主存和其它资源。

  用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。


2. 独立调度和分派的基本单位。

  在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。
  
3. 可并发执行。
  在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。
  
4. 共享进程资源。
  在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。
  线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。
  


#### 协程

协程，又称微线程，纤程。英文名Coroutine。

协程可以理解为用户级线程，协程和线程的区别是：线程是抢占式的调度，而协程是协同式的调度，协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。

使用协程改写生产者-消费者问题：

    import time

    def consumer():
        r = ''
        while True:
            n = yield r
            if not n:
                return
            print('[CONSUMER] Consuming %s...' % n)
            time.sleep(1)
            r = '200 OK'

    def produce(c):
        c.next()
        n = 0
        while n < 5:
            n = n + 1
            print('[PRODUCER] Producing %s...' % n)
            r = c.send(n)
            print('[PRODUCER] Consumer return: %s' % r)
        c.close()

    if __name__=='__main__':
        c = consumer()
        produce(c)
        
        
可以看到，使用协程不再需要显式地对锁进行操作。

#### IO多路复用

##### 基本概念

IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：

1. 当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。

2. 当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。

3. 如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。

4. 如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。

5. 如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。

与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。

##### 常见的IO复用实现

select(Linux/Windows/BSD Unix), epoll(Linux)，kqueue(BSD/Mac OS X)


参考资料：

* [浅谈进程同步与互斥的概念](http://www.cnblogs.com/CareySon/archive/2012/04/14/Process-SynAndmutex.html)
* [进程间同步——信号量](http://blog.csdn.net/feiyinzilgd/article/details/6765764)
* [百度百科：线程](http://baike.baidu.com/view/1053.htm)
* [进程、线程和协程的理解](http://blog.leiqin.info/2012/12/02/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3.html)
* [协程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868328689835ecd883d910145dfa8227b539725e5ed000)
* [IO多路复用之select总结](http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html)

### 内存管理

#### 内存分配

* 虚拟地址：用户编程时将代码（或数据）分成若干个段，每条代码或每个数据的地址由段名称 + 段内相对地址构成，这样的程序地址称为虚拟地址
* 逻辑地址：虚拟地址中，段内相对地址部分称为逻辑地址
* 物理地址：实际物理内存中所看到的存储地址称为物理地址

* 逻辑地址空间：在实际应用中，将虚拟地址和逻辑地址经常不加区分，通称为逻辑地址。逻辑地址的集合称为逻辑地址空间
* 线性地址空间：CPU地址总线可以访问的所有地址集合称为线性地址空间
* 物理地址空间：实际存在的可访问的物理内存地址集合称为物理地址空间

* MMU(Memery Management Unit内存管理单元)：实现将用户程序的虚拟地址（逻辑地址） → 物理地址映射的CPU中的硬件电路
* 基地址：在进行地址映射时，经常以段或页为单位并以其最小地址（即起始地址）为基值来进行计算
* 偏移量：在以段或页为单位进行地址映射时，相对于基地址的地址值

虚拟地址先经过分段机制映射到线性地址，然后线性地址通过分页机制映射到物理地址。

#### 虚拟内存

* 请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会调入

##### 页面置换算法

* FIFO算法

  先入先出，即淘汰最早调入的页面。
  
* OPT(MIN)算法
 
  选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。
  
  可惜，MIN需要知道将来发生的事，只能在理论中存在，实际不可应用。
  
* LRU(Least-Recently-Used)算法

  用过去的历史预测将来，选最近最长时间没有使用的页淘汰(也称最近最少使用)。

  LRU准确实现：计数器法，页码栈法。
  
  由于代价较高，通常不使用准确实现，而是采用近似实现，例如Clock算法。
  
  
**内存抖动现象**：页面的频繁更换，导致整个系统效率急剧下降，这个现象称为内存抖动（或颠簸）。抖动一般是内存分配算法不好，内存太小引或者程序的算法不佳引起的。

**Belady现象**：对有的页面置换算法，页错误率可能会随着分配帧数增加而增加。

FIFO会产生Belady异常。

栈式算法无Belady异常，LRU，LFU（最不经常使用），OPT都属于栈式算法。

### 磁盘与文件

#### 磁盘调度

磁盘访问延迟 = 队列时间 + 控制器时间 + 寻道时间 + 旋转时间 + 传输时间

磁盘调度的目的是减小延迟，其中前两项可以忽略，寻道时间是主要矛盾。

##### 磁盘调度算法

* FCFS

  先进先出的调度策略，这个策略具有公平的优点，因为每个请求都会得到处理，并且是按照接收到的顺序进行处理。
    
* SSTF(Shortest-seek-time First 最短寻道时间优先)

  选择使磁头从当前位置开始移动最少的磁盘I/O请求，所以 SSTF 总是选择导致最小寻道时间的请求。
  
  总是选择最小寻找时间并不能保证平均寻找时间最小，但是能提供比 FCFS 算法更好的性能，会存在饥饿现象。
  
* SCAN

  SSTF+中途不回折，每个请求都有处理机会。
  
  SCAN 要求磁头仅仅沿一个方向移动，并在途中满足所有未完成的请求，直到它到达这个方向上的最后一个磁道，或者在这个方向上没有其他请求为止。
  
  由于磁头移动规律与电梯运行相似，SCAN 也被称为电梯算法。
  
  SCAN 算法对最近扫描过的区域不公平，因此，它在访问局部性方面不如 FCFS 算法和 SSTF 算法好。
  
* C-SCAN
  
  SCAN+直接移到另一端，两端请求都能很快处理。
  
  把扫描限定在一个方向，当访问到某个方向的最后一个磁道时，磁道返回磁盘相反方向磁道的末端，并再次开始扫描。
  
  其中“C”是Circular（环）的意思。
  
* LOOK 和 C-LOOK
  釆用SCAN算法和C-SCAN算法时磁头总是严格地遵循从盘面的一端到另一端，显然，在实际使用时还可以改进，即磁头移动只需要到达最远端的一个请求即可返回，不需要到达磁盘端点。这种形式的SCAN算法和C-SCAN算法称为LOOK和C-LOOK调度。这是因为它们在朝一个给定方向移动前会查看是否有请求。
  
#### 文件系统

##### 分区表

* MBR：支持最大卷为2 TB（Terabytes）并且每个磁盘最多有4个主分区（或3个主分区，1个扩展分区和无限制的逻辑驱动器）
* GPT：支持最大卷为18EB（Exabytes）并且每磁盘的分区数没有上限，只受到操作系统限制（由于分区表本身需要占用一定空间，最初规划硬盘分区时，留给分区表的空间决定了最多可以有多少个分区，IA-64版Windows限制最多有128个分区，这也是EFI标准规定的分区表的最小尺寸。另外，GPT分区磁盘有备份分区表来提高分区数据结构的完整性。

##### RAID 技术

磁盘阵列（Redundant Arrays of Independent Disks，RAID），独立冗余磁盘阵列之。原理是利用数组方式来作磁盘组，配合数据分散排列的设计，提升数据的安全性。

* RAID 0

  RAID 0是最早出现的RAID模式，需要2块以上的硬盘，可以提高整个磁盘的性能和吞吐量。
  
  RAID 0没有提供冗余或错误修复能力，其中一块硬盘损坏，所有数据将遗失。
  
* RAID 1

  RAID 1就是镜像，其原理为在主硬盘上存放数据的同时也在镜像硬盘上写一样的数据。
  
  当主硬盘（物理）损坏时，镜像硬盘则代替主硬盘的工作。因为有镜像硬盘做数据备份，所以RAID 1的数据安全性在所有的RAID级别上来说是最好的。
  
  但无论用多少磁盘做RAID 1，仅算一个磁盘的容量，是所有RAID中磁盘利用率最低的。
  
* RAID 2
  
  这是RAID 0的改良版，以汉明码（Hamming Code）的方式将数据进行编码后分区为独立的比特，并将数据分别写入硬盘中。因为在数据中加入了错误修正码（ECC，Error Correction Code），所以数据整体的容量会比原始数据大一些，RAID2最少要三台磁盘驱动器方能运作。
  

* RAID 3
  采用Bit－interleaving（数据交错存储）技术，它需要通过编码再将数据比特分割后分别存在硬盘中，而将同比特检查后单独存在一个硬盘中，但由于数据内的比特分散在不同的硬盘上，因此就算要读取一小段数据资料都可能需要所有的硬盘进行工作，所以这种规格比较适于读取大量数据时使用。
  
* RAID 4

它与RAID 3不同的是它在分区时是以区块为单位分别存在硬盘中，但每次的数据访问都必须从同比特检查的那个硬盘中取出对应的同比特数据进行核对，由于过于频繁的使用，所以对硬盘的损耗可能会提高。（块交织技术，Block interleaving）

**RAID 2/3/4 在实际应用中很少使用**

* RAID 5 

  RAID Level 5是一种储存性能、数据安全和存储成本兼顾的存储解决方案。它使用的是Disk Striping（硬盘分区）技术。
  
  RAID 5至少需要三块硬盘，RAID 5不是对存储的数据进行备份，而是把数据和相对应的奇偶校验信息存储到组成RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。
  
  RAID 5 允许一块硬盘损坏。
  
  实际容量 `Size = (N-1) * min(S1, S2, S3 ... SN)`
  
* RAID 6

  与RAID 5相比，RAID 6增加第二个独立的奇偶校验信息块。两个独立的奇偶系统使用不同的算法，数据的可靠性非常高，即使两块磁盘同时失效也不会影响数据的使用。
  
  RAID 6 至少需要4块硬盘。
  
  实际容量 `Size = (N-2) * min(S1, S2, S3 ... SN)`
  
* RAID 10/01（RAID 1+0，RAID 0+1）

  RAID 10是先镜射再分区数据，再将所有硬盘分为两组，视为是RAID 0的最低组合，然后将这两组各自视为RAID 1运作。

  RAID 01则是跟RAID 10的程序相反，是先分区再将数据镜射到两组硬盘。它将所有的硬盘分为两组，变成RAID 1的最低组合，而将两组硬盘各自视为RAID 0运作。

  当RAID 10有一个硬盘受损，其余硬盘会继续运作。RAID 01只要有一个硬盘受损，同组RAID 0的所有硬盘都会停止运作，只剩下其他组的硬盘运作，可靠性较低。如果以六个硬盘建RAID 01，镜射再用三个建RAID 0，那么坏一个硬盘便会有三个硬盘脱机。因此，RAID 10远较RAID 01常用，零售主板绝大部份支持RAID 0/1/5/10，但不支持RAID 01。
  
  RAID 10 至少需要4块硬盘，且硬盘数量必须为偶数。
  
##### 常见文件系统

* Windows: FAT, FAT16, FAT32, NTFS
* Linux: ext2/3/4, btrfs, ZFS
* Mac OS X: HFS+

##### Linux文件权限

Linux文件采用10个标志位来表示文件权限，如下所示：

    -rw-r--r--  1 skyline  staff    20B  1 27 10:34 1.txt
    drwxr-xr-x   5 skyline  staff   170B 12 23 19:01 ABTableViewCell

第一个字符一般用来区分文件和目录，其中：

* d：表示是一个目录，事实上在ext2fs中，目录是一个特殊的文件。
* －：表示这是一个普通的文件。
* l: 表示这是一个符号链接文件，实际上它指向另一个文件。
* b、c：分别表示区块设备和其他的外围设备，是特殊类型的文件。
* s、p：这些文件关系到系统的数据结构和管道，通常很少见到。

第2～10个字符当中的每3个为一组，左边三个字符表示所有者权限，中间3个字符表示与所有者同一组的用户的权限，右边3个字符是其他用户的权限。

这三个一组共9个字符，代表的意义如下：

* r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限
* w(Write,写入)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。
* x(eXecute，执行)：对文件而言，具有执行文件的权限；对目录来说该用户具有进入目录的权限。

权限的掩码可以使用十进制数字表示：

* 如果可读，权限是二进制的100，十进制是4；
* 如果可写，权限是二进制的010，十进制是2；
* 如果可运行，权限是二进制的001，十进制是1；

* 具备多个权限，就把相应的 4、2、1 相加就可以了：

  若要 rwx 则 4+2+1=7
  若要 rw- 则 4+2=6
  若要 r-x 则 4+1=5
  若要 r-- 则 =4
  若要 -wx 则 2+1=3
  若要 -w- 则 =2
  若要 --x 则 =1
  若要 --- 则 =0

默认的权限可用umask命令修改，用法非常简单，只需执行umask 777命令，便代表屏蔽所有的权限，因而之后建立的文件或目录，其权限都变成000，

依次类推。通常root帐号搭配umask命令的数值为022、027和 077，普通用户则是采用002，这样所产生的权限依次为755、750、700、775。

**chmod，chgrp，chown** 

chmod命令非常重要，用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。

该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。

1. 文字设定法

  chmod ［who］ ［+ | - | =］ ［mode］ 文件名

  命令中各选项的含义为：

  操作对象who可是下述字母中的任一个或者它们的组合：

  * u 表示“用户（user）”，即文件或目录的所有者。
  * g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。
  * o 表示“其他（others）用户”。
  * a 表示“所有（all）用户”。它是系统默认值。

  操作符号可以是：

  * + 添加某个权限。
  * - 取消某个权限。
  * = 赋予给定权限并取消其他所有权限（如果有的话）。


  设置mode所表示的权限可用下述字母的任意组合：

  * r 可读。
  * w 可写。
  * x 可执行。
  * X 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性。
  * s 在文件执行时把进程的属主或组ID置为该文件的文件属主。方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位。
  * t 保存程序的文本到交换设备上。
  * u 与文件属主拥有一样的权限。
  * g 与和文件属主同组的用户拥有一样的权限。
  * o 与其他用户拥有一样的权限。

  文件名：以空格分开的要改变权限的文件列表，支持通配符。

  在一个命令行中可给出多个权限方式，其间用逗号隔开。例如：`chmod g+r，o+r example` 使同组和其他用户对文件example 有读权限。

2. 数字设定法

  直接使用数字表示的权限来更改：
  
  例： $ chmod 644 mm.txt
  
  
**chgrp命令**

功能：改变文件或目录所属的组。

语法：chgrp ［选项］ group filename

例：$ chgrp - R book /opt/local /book

改变/opt/local /book/及其子目录下的所有文件的属组为book。

**chown命令**

功能：更改某个文件或目录的属主和属组。这个命令也很常用。例如root用户把自己的一个文件拷贝给用户xu，为了让用户xu能够存取这个文件，root用户应该把这个文件的属主设为xu，否则，用户xu无法存取这个文件。

语法：chown ［选项］ 用户或组 文件

说明：chown将指定文件的拥有者改为指定的用户或组。用户可以是用户名或用户ID。组可以是组名或组ID。文件是以空格分开的要改变权限的文件列表，支持通配符。
  
例：把文件shiyan.c的所有者改为wang。

    chown wang shiyan.c


参考资料：

* [操作系统中的磁盘调度算法](http://www.educity.cn/windows/621734.html)
* [百度百科：磁盘阵列](http://baike.baidu.com/view/63423.htm)
* [维基百科：RAID](https://zh.wikipedia.org/wiki/RAID)
* [Linux文件权限详解](http://blog.chinaunix.net/uid-25052030-id-174343.html)
* [修改Linux文件权限命令:chmod](http://www.cnblogs.com/avril/archive/2010/03/23/1692809.html)


数据库
-----

### 事务处理

##### 事务的概念

事务的概念来自于两个独立的需求：并发数据库访问，系统错误恢复。

一个事务是可以被看作一个单元的一系列SQL语句的集合。

##### 事务的特性（ACID）

* A, atomacity 原子性
  事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。
  
* C, consistency 一致性 

  事务将数据库从一种一致状态转变为下一种一致状态。也就是说，事务在完成时，必须使所有的数据都保持一致状态（各种 constraint 不被破坏）。
  
* I, isolation 隔离性
  由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。换句话说，一个事务的影响在该事务提交前对其他事务都不可见。
  
* D, durability 持久性

  事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。
  
##### 事务的隔离级别

如果不对数据库进行并发控制，可能会产生异常情况：

1. 脏读(Dirty Read)

  当一个事务读取另一个事务尚未提交的修改时，产生脏读。
  
  同一事务内不是脏读。
  一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚，也就是说读取出的数据其实是错误的。
  
2. 非重复读(Nonrepeatable Read)
  一个事务对同一行数据重复读取两次，但是却得到了不同的结果。同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生非重复读。 
  
3. 幻像读(Phantom Reads) 
  事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。
  
  当对某行执行插入或删除操作，而该行属于某个事务正在读取的行的范围时，会发生幻像读问题。
  
4. 丢失修改(Lost Update) 

  第一类：当两个事务更新相同的数据源，如果第一个事务被提交，第二个却被撤销，那么连同第一个事务做的更新也被撤销。
  
  第二类：有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。
  
  
为了兼顾并发效率和异常控制，在标准SQL规范中，定义了4个事务隔离级别，（ Oracle 和 SQL Server 对标准隔离级别有不同的实现 ）  

1. 未提交读(Read Uncommitted) 
  
  直译就是"读未提交"，意思就是即使一个更新语句没有提交，但是别的事务可以读到这个改变。
  
  Read Uncommitted允许脏读。
  
2. 已提交读(Read Committed)

  直译就是"读提交"，意思就是语句提交以后，即执行了 Commit 以后别的事务就能读到这个改变，只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别。
  
  Read Commited 不允许脏读，但会出现非重复读。
  
  
3. 可重复读(Repeatable Read)：
   
   直译就是"可以重复读"，这是说在同一个事务里面先后执行同一个查询语句的时候，得到的结果是一样的。
   
   Repeatable Read 不允许脏读，不允许非重复读，但是会出现幻象读。
   
   
4. 串行读(Serializable)
   
   直译就是"序列化"，意思是说这个事务执行的时候不允许别的事务并发执行。完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。
   
   Serializable 不允许不一致现象的出现。
   
##### 事务隔离的实现——锁

1. 共享锁(S锁)

  用于只读操作(SELECT)，锁定共享的资源。共享锁不会阻止其他用户读，但是阻止其他的用户写和修改。

2. 更新锁(U锁)

  用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。
  
3. 独占锁(X锁，也叫排他锁)

  一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁包括共享缩。写是独占锁，可以有效的防止“脏读”。

Read Uncommited 如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。

Read Committed 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。可以通过“瞬间共享读锁”和“排他写锁”实现。

Repeatable Read 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。可以通过“共享读锁”和“排他写锁”实现。

Serializable 读加共享锁，写加排他锁，读写互斥。


参考资料：

* [百度百科：数据库事务](http://baike.baidu.com/view/1298364.htm)
* [数据库事务隔离级别与锁](http://www.cnblogs.com/tqsummer/archive/2010/07/11/1775209.html)
* [SQL SERVER的锁机制（四）——概述（各种事务隔离级别发生的影响）](http://www.cnblogs.com/chillsrc/archive/2013/04/27/3047547.html)
* [数据库锁](http://www.cnblogs.com/zhouqianhua/archive/2011/04/15/2017049.html)
* [关于数据库事务、隔离级别、锁的理解与整理](http://news.e800.com.cn/articles/2011/0803/492650.shtml)
* [Innodb中的事务隔离级别和锁的关系](http://tech.meituan.com/innodb-lock.html)

编译原理
--------

### 编译器

#### 编译器结构

* 词法分析器

* 语法分析器

* 语义分析及中间代码生成

* 代码优化

* 代码生成



